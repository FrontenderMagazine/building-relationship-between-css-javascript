# Распределение задач между CSS и JavaScript #

Без сомнения, популярность JavaScript невероятна, что подтверждается
повсеместным использованием jQuery, Prototype, Node.js, Backbone.js, Mustache и
тысяч других библиотек. Этот язык настолько популярен, что его часто
используют даже там, где другое решение было бы более удачным в долгосрочной
перспективе.

Мы используем отдельные файлы для разделения JavaScript, HTML и CSS, и в то же
время нарушаем принципы концепции прогрессивного улучшения, используя плагины
jQuery и всевозможные приёмы с использованием JavaScript, количество которых
постоянно растёт. JavaScript настолько основательно вошел в жизнь веб-
разработчиков, что довольно часто его применяют вместо HTML для построения
структуры документа, также как и вместо CSS для включения стилей в документ. 
Я не собираюсь критиковать использование JavaScript-библиотек, фреймворков 
и шаблонов, моя цель – предложить анализ сложившейся ситуации и альтернативные
решения для конкретных задач.

## Разделение CSS и JavaScript ##

Как известно, CSS применяется к HTML при помощи различных селекторов.
Используя идентификаторы, классы или даже любой атрибут (в том числе
пользовательский) можно легко изменить стиль элемента. То же самое можно
сделать и различными способами оперируя JavaScript, и, честно говоря, это так
же просто, только синтаксис используется другой (это одно из моих собственных
открытий в процессе работы с JavaScript).

Подход прогрессивного улучшения – стал настолько популярным во многом благодаря
тому, что он позволяет подключить файлы JavaScript и CSS к файлу с чистым HTML.
Концепция прогрессивного улучшения служит отправной точкой при работе над
проектом и напоминает нам о том, что «[Лучи не должны пересекаться][1]» . 
> (Популярная фраза из сериала Ghostbusters. Имеется ввиду то, что каждый язык
веб-разработки 
> обладает собственными функциями и особенностями, и смешивание
этих языков крайне нежелательно).

Тем не менее, по мере усложнения используемого JavaScript-кода и разработки
приложений со сложными интерактивными элементами, становится все труднее не
только разделять HTML и JavaScript, но также удержаться от изменения
форматирования документа с помощью JavaScript. Конечно же, нельзя категорично
ответить на вопрос о том, стоит ли управлять внешним видом документа с помощью
JavaScript. Во многих случаях может возникнуть необходимость подключать стили
постепенно, например в drag-and-drop интерфейсах, где позиционирование элемента
должно постоянно меняться в зависимости от позиции курсора (или пальцев
пользователя).

Стоит заметить, что возложить все функции документа на CSS довольно удобно,
указывая стиль элементов при помощи многоцелевых универсальных классов. Такой
подход к веб-разработке более гибкий, нежели использование частичек CSS-кода
вперемешку с кодом JavaScript и его можно сравнить с подходом к разделению
презентационной информации и HTML. Мы тщательно придерживаемся модели
прогрессивного улучшения, когда имеем дело с HTML и CSS, но когда дело доходит
до JavaScript – всё начинает разваливаться. Эта проблема определенно
заслуживает нашего внимания.

Множество фронт-энд разработчиков гордится тем, что у них «чистый» HTML. С ним
легко работать, а некоторые энтузиасты считают написание такого кода своего
рода исскуством. Чистый статичный HTML – это прекрасно, но какой от него толк,
если сгенерированный HTML-код страницы исковеркан стилями, вставленными с
помощью JavaScript, и кусками несемантической разметки? Под «сгенерированным
HTML-кодом» я подразумеваю код, который мы видим после обработки исходного HTML
плагинами jQuery и JavaScript-кодом. Если первым шагом к получению чистого HTML
и разделения слоёв оформления документа, согласно подходу прогрессивного
улучшения, можно считать отказ от использования атрибута `style`, то в качестве
второго шага я бы предложил отказ от использования приёмов JavaScript, для
которых в HTML-код добавляется атрибут `style`.

## Очистка кода HTML ##

Наверное, все согласятся, что использование готовых приёмов вслепую, как
правило, чревато множеством проблем и неприятностей. Библиотека jQuery
настолько сложна, что зачастую мы просто копируем вслепую её готовый код, не
всегда до конца понимая как именно он работает. В качестве примера можно
привести поведение метода `hide()` библиотеки jQuery: воспоминание об этом
примере постоянно сдерживает меня от смешания CSS и JavaScript. Придерживаясь
принципов подхода прогрессивного улучшения, вряд ли кто-то станет использовать
встроенный CSS, чтобы написать код вроде этого:

  <div class="content-area" style="display:none;"></div>
  
Такой код не стоит использовать, потому что скринридеры пропускают элементы для
которых указан стиль display:none, к тому же, указание стиля загружает HTML-код
презентационными данными. То же самое происходит при применении методов jQuery
вроде `hide()` - он присваивает `style` для определённой части кода и указывает
для её атрибута `display` – параметр `none`. Метод `hide()` упрощает работу с
кодом, но негативно влияет на доступность конечного продукта веб-разработки
(accessibility). Используя этот метод, мы также нарушаем правила прогрессивного
улучшения, поскольку он требует добавление описания стиля в HTML-код (мы любим
грешить беспорядком в коде, не так ли?). Метод `hide()` часто применяется в
интерфейсах с вкладками для сокрытия содержимого вкладок. В результате,
скринридеры не видят скрытое содержимое вообще. Так как управление стилями с
помощью JavaScript, в большинстве случаев, не лучший вариант, мы можем
обратиться с этой целью к классам CSS:

**CSS**

1  .hide {
2   display: none;
3  }

**jQuery**

1  $('.content-area').addClass('hide');

Использование `display:none` для скрытия содержимого также негативно влияет на
доступность документа, но так как мы больше не используем готовый метод jQuery,
можно с легкостью указать, когда именно содержимое должно быть скрыто (для
этого можно использовать любой привычный способ). Можем также использовать что-
то вроде:

**CSS**

1  .hide {
2   position: absolute;
3   top: -9999px;
4   left: -9999px;
5  }
6  
7  .remove {
8   display: none;
9  }

Элемент можно скрыть из поля видимости, подключив к нему любой из приведенных в
примере классов, но с точки зрения доступности они работают по-разному.
Взглянув на такой код, сразу понимаем, что это описание внешнего вида документа
и место ему в файле CSS. Универсальные многоцелевые классы, такие как в примере
выше, позволяют сократить использование кода JavaScript и могут быть подключены
к разным элементам, что приветствуется объектно-ориентированным подходом к
написанию CSS (OOCSS). Мы получаем возможность не только избежать дублирования
стилей в CSS, но и применить более целостный подход к фронт-энд разработке
проекта в целом. Лично я вижу для себя много преимуществ в возможности
полностью контролировать поведение документа, хотя многим это может показаться
чрезмерной зацикленностью на контроле.

## Особенности применения в веб-среде и в команде веб-разработчиков ##

Таким образом, мы можем использовать сильные стороны языков CSS и JavaScript,
соблюдая между ними равновесие. Крайне важно уделить должное внимание созданию
сбалансированного продукта в процессе фронт-энд разработки, чтобы он был
способен противостоять уязвимости веб-среды, ведь мы не в силах решить проблемы
на клиентской стороне также легко и быстро, как на стороне сервера. Если браузер
пользователя старый и медленный, в большинстве случаев мы не можем это исправить
(оффтоп: свою бабушку, правда, я уже приучил к Google Crome), мы можем лишь
предвидеть неожиданности ожидающие наш продукт в веб-среде, готовиться к
худшему и надяться на лучшее.

Со мной часто спорят, мол, подключать CSS-классы к HTML-документу с помощью
JavaScript неудобно, когда над проектом работает несколько разработчиков. Так
как в большинстве случаев CSS готов до того, как начинается написание кода
JavaScript и классы, которые были созданы для того, чтобы подключаться с
помощью JavaScript, могут потеряться в общей массе кода. Как результат мы
получаем внушительное количество продублированного кода. В таких случаях я
советую постучать себя по лбу, открыть AIM, GTalk или Skype и сообщить
сотрудникам о классах, которые были созданы специально для подключения
JavaScript. Бытует мнение, что все общение между веб-разработчиками сводится к
обмену сообщениями в системах управления файлами вроде Git , но, поверьте, от
набора пары строчек дополнительного текста никто не пострадает.

## Использование динамического CSS с подстраховкой в Javascript ##

Использование JavaScript для подключения объектов CSS имеет и более широкое
применение, чем сокрытие и отображение содержимого. Оно позволяет использовать
динамические CSS – переходы, анимацию, трансформации – все те эффекты, которые
сейчас зачастую прописываются при помощи JavaScript. Разберем простой пример
применения эффекта постепенного исчезания для div–блока при нажатии на него. В
этом примере продемонстрировано как его можно реализовать с помощью CSS,
продублировав те же эффекты в JavaScript-коде в качестве подстраховки для
браузеров, которые не поддерживают используемое CSS-свойство transition.

Мы будем использовать:
* [jQuery][2] 
* [Modernizr][3]

Сначала подготовим `body`: 

1  <body>
2    <button type="button">Run Transition</button>
3    <div id="cube"></div><!--/#cube-->
4  </body>

Теперь пропишем CSS:

01 #cube {
02   height: 200px;
03   width: 200px;
04   background: orange;
05   -webkit-transition: opacity linear .5s;
06    -moz-transition: opacity linear .5s;
07     -o-transition: opacity linear .5s;
08       transition: opacity linear .5s;
09 }
10  
11 .fade-out {
12   opacity: 0;
13 }

Перед добавлением JavaScript-кода - отвлечемся немного чтобы разобраться с тем, что 
мы собираемся сделать:
1. Используем библиотеку Modernizr, чтобы проверить поддерживается ли CSS-свойство 
`transition`.
2. Если оно подерживается:
2.1. Присваиваем кнопке button onclick – событие, которое при нажатии на кнопку будет 
подключать класс `fade-out` к элеменнту с идентификатором `#cube`.
2.2. Добавляем слушатель события, который определит когда будет завершен `transition`. 
Используя его, мы можем задать функцию, которая удалит идентификатор `#cube` из структуры 
DOM.
3. Если transition не поддерживается:
3.1. Присваиваем кнопке button onclick – событие, которое будет запускать метод jQuery 
`animate()`. Это позволит применить эффект постепенного исчезания элемента с идентификатором 
`#cube`.
3.2. Используем callback-функцию, чтобы удалить `#cube` из структуры DOM.

После окончания transition на основе CSS, выполняется дополнительное событие
transitionend. Также, в конце более сложных взаимодействий на основе анимации
CSS, выполняется дополнительное событие animationend.

Сначала нужно прописать переменные JavaScript:

01 (function () {
02  
03   // прописываем переменные
04   var elem = document.getElementById('cube'),
05     button = document.getElementById('do-it'),
06     transitionTimingFunction = 'linear',
07     transitionDuration = 500,
08     transitionend;
09  
10   // прописываем синтаксис свойства transitionend, используя вендорные префиксы
11   if ($.browser.webkit) {
12     transitionend = 'webkitTransitionEnd'; // safari & chrome
13   } else if ($.browser.mozilla) {
14     transitionend = 'transitionend'; // firefox
15   } else if ($.browser.opera) {
16     transitionend = 'oTransitionEnd'; // opera
17   } else {
18     transitionend = 'transitionend'; // best guess at the default?
19   }
20  
21   //... добавляем остальной код сюда.
22  
23 })(); // конец обёртывающей функции

Вы наверное заметили, что для события `transitionend` был добавлен вендорный
префикс и для каждого браузера полностью указано название события. Как правило,
достаточно определить вендорный префикс и добавить его к названию события, но в
этом случае синтаксис немного отличается, поэтому следует указывать имя события
с каждым префиксом целиком.

Далее мы будем использовать Modernizr, чтобы подтвердить поддержку свойства
`transition` и в каждом случае добавим слушатель события (все это помещается в
обёртывающую функцию):

01 // с помощью Modernizr проверяем наличие поддержки transition
02 if(Modernizr.csstransitions) {
03  
04   // подключение класса при клике мышкой
05   $(button).on('click', function () {
06     $(elem).addClass('fade-out');
07   });
08    
09   // имитация callback-функции при помощи слушателя события
10   elem.addEventListener(transitionend, function () {
11     theCallbackFunction(elem);
12   }, false);
13     
14 } else {
15  
16   // слушатель события для браузеров, не поддерживающих предыдущий вариант 
17   $(button).on('click', function () {
18  
19     $(elem).animate({
20       'opacity' : '0'
21     }, transitionDuration, transitionTimingFunction, function () {
22       theCallbackFunction(elem);
23     });
24  
25   }); // конец события
26  
27 } // конец проверки 

И наконец, нам нужно указать общую функцию для обеих процессов, которая будет
выполняться после завершения transition (или animation). Чтобы не усложнять наш
пример, назовем её просто `theCallbackFunction()` (хотя технически – она не
является callback-функцией). Она удалит элемент из структуры DOM и выведет на
панель консоли сообщение о том, что функция была выполнена успешно.

01 // прописываем callback-функцию, что происходит после завершения transition/animation
02 function theCallbackFunction (elem) {
03  
04   'use strict';
05  
06   // удаление элемента из DOM
07   $(elem).remove();
08  
09   // вывод сообщения об успешном завершении
10   console.log('the transition is complete');
11  
12 }

Вне зависимости от того, какой браузер используется – от IE 7 (в худшем случае),
до мобильной версии Safari или Chrome – эффект будет идентичным. Разница скрыта
«под капотом»; пользователь её не заметит. Подобным образом можно использовать
и другие передовые техники, не жертвуя при этом качеством продукта, для
пользователей более старых браузеров. Такой подход также позволяет разделять
CSS и JavaScript, что и было нашей целью.

## Итог ##

Возможно, вы спрашиваете себя: зачем усложнять себе жизнь дополнительной
роботой? Мы написали 60 строчек кода JavaScript для того, чтобы воспроизвести
эффект на который требуется 8 строчек jQuery. Что сказать, никто не говорил,
что следить за чистотой кода и придерживаться подхода прогрессивного улучшения
– самая лёгкая задачка, из выполняемых вами. Напротив, гораздо легче не
обращать на это внимание вовсе. Однако, обязанность ответственных разработчиков
– следить за тем, чтобы разработанные нами приложения были доступны максимально
широкому кругу пользователей и в будущем их можно было бы легко перенастроить
под новые требования. Если вам, так же как и мне, не жаль потратить немного
времени на то, чтобы обеспечить бесперебойную работу результата вашего труда,
тогда стоит приложить все усилия для «отделения зерён от плевел» и разработки
приложения, которое будет соответствовать всем требованиям идеологии
постепенного улучшения и «graceful degradation».

Представленная модель также позволяет максимально использовать сильные стороны
CSS, такие как отзывчивый дизайн и возможность корректировки взаимодествия с
пользователем, основываясь на разрешении его экрана. Особенно заметна разница
при использовании устройств с низкой производительностью, ведь, как всем
известно, CSS скачивается и обрабатывается намного быстрее чем JavaScript.
Возможность переложить некоторые задачи с JavaScript на CSS – это огромный плюс.

На практике мы уже используем переходы и анимацию CSS для создания мелких
взаимодествий, таких как смена внешнего вида элеменнта при наведении курсора
(hover-эффекты), вращающаяся графика, пульсирующие обьекты. В скором времени
CSS получит статус общепризнанного могущественного языка, который отлично
читается браузерами и будет активно использоваться для построения сложных
взаимодействий, пока не реализованных при помощи JavaScript. Если вам нужен
надежный инструмент, не требующий обильной затраты ресурсов, относительно
простой в вопросах поддержки и позволяющий использовать передовые возможности
браузеров – скорее всего, пришло время пересмотреть свой подход к распределению
задач между CSS и JavaScript. Как сказал один умный человек: «Чтобы написать
хороший код JavaScript, нужно знать, когда вместо него стоит использовать CSS»
(Этот человек - я).

Автор: Тим Райт (Tim Wright)

[1]: http://www.youtube.com/watch?v=jyaLZHiJJnE
[2]: http://jquery.com/
[3]: http://modernizr.com/
