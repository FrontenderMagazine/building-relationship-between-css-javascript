# Распределение задач между CSS и JavaScript #

Популярность JavaScript невероятна, что подтверждается
широким использованием jQuery, Prototype, Node.js, Backbone.js, Mustache и
тысяч других библиотек. Этот язык настолько популярен, что его часто
используют даже там, где другое решение было бы более удачным в долгосрочной
перспективе.

Даже если мы используем отдельные файлы для хранения JavaScript, HTML и CSS, принципы
прогрессивного улучшения нарушаются с каждым jQuery-плагином, который мы подлкючаем,
и с использованием каждой новой техники, количество которых растет с каждым днём. 
JavaScript настолько мощен, что его возможности часто пересекаются с HTML (например, при пострении структуры документа) и CSS (при добавлении стилей).
Я не собираюсь критиковать использование JavaScript-библиотек, фреймворков 
и шаблонов, моя цель – предложить анализ сложившейся ситуации и альтернативные
решения для конкретных задач.

## Не смешивайте CSS и JavaScript ##

Как известно, CSS применяется к HTML с помощью различных селекторов.
Используя идентификаторы, классы или атрибуты (в том числе
пользовательские) можно легко изменить стиль элемента. То же самое можно
сделать множеством способов используя JavaScript, и, честно говоря, это то же 
самое, только синтаксис другой (это одно из моих собственных
открытий в процессе работы с JavaScript). Простой доступ к HTML из JavaScript и CSS
является одной из причин, по которой прогрессивное улучшение стало настолько 
популярным подходом в веб-разработке. Этот подход нам служит ориентиром при работе 
над проектом и напоминает о том, что «[Лучи не должны пересекаться][1]» . 
> (Популярная фраза из сериала Ghostbusters. Имеется ввиду то, что каждый язык
веб-разработки 
> обладает собственными функциями и особенностями, и смешивание
этих языков крайне нежелательно).

Тем не менее, по мере усложнения используемого JavaScript-кода и разработки
приложений со сложными интерактивными элементами, становится все труднее не
только разделять HTML и JavaScript, но также удержаться от включения
стилей непосредственно в документ. Конечно, нельзя однозначно
ответить на вопрос стоит ли управлять внешним видом документа с помощью
JavaScript. Во многих случаях может возникнуть необходимость добавлять стили
динамически, например в drag-and-drop интерфейсах, где позиционирование элемента
должно постоянно меняться в зависимости от положения курсора или пальцев
пользователя.

Но вообще говоря, вы можете удобно хранить всю информацию о стилях документа
в CSS-файлах и подключать нужные стили через переиспользуемые классы. Такое
решение является более гибким, чем добавление стилей с помощью 
JavaScript, и его можно соотнести с подходом, предполагающим 
разделение презентационной информации и HTML. Мы следуем этой модели
когда имеем дело только с HTML и CSS, но когда в дело 
вступает JavaScript – всё пытается развалиться на части. 
Эта проблема определенно заслуживает нашего внимания.

Множество фронт-энд разработчиков гордится тем, что у них «чистый» HTML. С ним
легко работать, а некоторые энтузиасты считают написание такого кода своего
рода искусством. Чистый статичный HTML – это прекрасно, но какой в этом смысл,
если в итоге сгенерированный HTML-код страницы испещрён динамически 
добавленными стилями и кусками несемантической разметки? Под «сгенерированным
HTML-кодом» я подразумеваю то, что мы получим после того как исходный HTML
будет обработан плагинами и прочим JavaScript. Если первым шагом к 
получению чистого HTML и отделению оформления от разметки, согласно подходу
прогрессивного улучшения, можно считать отказ от атрибута `style`, то в качестве
второго шага я бы предложил отказ от использования JavaScript, который 
добавляет атрибут `style` в разметку документа.

## Очищаем HTML-код ##

Наверное, все согласятся, что слепое использование технологий, как
правило, плохая идея. Довольно часто применяя Jquery мы пользуемся 
широкими возможностями библиотеки без полного понимания как всё это
работает под капотом. В качестве примера того, как сложно на самом деле избежать
смешивания JavaScript и CSS можно привести поведение jQuery-метода `hide()`. Следуя
принципам прогрессивного улучшения, вы вряд ли будете использовать 
инлайновые стили таким образом:

  <div class="content-area" style="display:none;"></div>
  
Такой код не стоит использовать, потому что скринридеры пропускают элементы для
которых указан стиль `display:none`, к тому же инлайн-стили забивают HTML-код
ненужными презентационными данными. 
Когда вы испоьзуете jQuery-метод `hide()`, он присваивает `style` 
заданному элементу и указывает для свойства `display` параметр `none`. 
`hide()` упрощает работу с кодом, но плохо влияет на 
доступность содержимого страницы. Используя этот метод, мы также нарушаем правила прогрессивного
улучшения, поскольку он требует добавление стилей в HTML-код (мы любим
грешить беспорядком в коде, не так ли?). Метод `hide()` часто применяется в
интерфейсах с вкладками для сокрытия содержимого вкладок, в результате,
скринридеры не видят скрытое содержимое вообще. Так как управление стилями с
помощью JavaScript, в большинстве случаев, не лучший вариант, мы можем
переместить их в CSS и обратиться к ним с помощью класса:

**CSS**

1  .hide {
2   display: none;
3  }

**jQuery**

1  $('.content-area').addClass('hide');

Использование `display:none` для скрытия содержимого также негативно влияет на
доступность документа, но, так как мы больше не используем готовый метод jQuery,
можно с легкостью указать, когда именно содержимое должно быть скрыто (для
этого можно использовать любой привычный способ). Можем также использовать что-
то вроде:

**CSS**

1  .hide {
2   position: absolute;
3   top: -9999px;
4   left: -9999px;
5  }
6  
7  .remove {
8   display: none;
9  }

Элемент можно скрыть со страницы подключив к нему любой из приведенных в
примере классов, но с точки зрения доступности они работают по-разному.
При взгляде на такой код сразу становится ясно, что это описание внешнего 
вида документа и место ему в файле с CSS. Универсальные многоцелевые классы, 
как в примере выше, позволяют уменьшить код JavaScript 
и могут быть переиспользованы, что приветствуется
объектно-ориентированным подходом к написанию CSS (OOCSS). Мы получаем
возможность не только избежать дублирования
стилей в CSS, но и применить более целостный подход к фронт-энд разработке
проекта в целом. Лично я вижу для себя много преимуществ в возможности
контролировать поведение элементов таким образом, хотя многим это может
показаться чрезмерной увлеченностью контролем.

## Особенности применения в веб-среде и в команде веб-разработчиков ##

Таким образом, мы можем использовать сильные стороны языков CSS и JavaScript,
не теряя равновесие. Создание баланса в фронт-энд разработке крайне важно,
потому что веб-окружение очень хрупко, и мы не можем контролировать его так же
легко как серверную часть. Если у пользователя установлен старый и медленный
браузер, в большинстве случаев, мы не можем это исправить
(оффтоп: свою бабушку, правда, я уже приучил к Google Crome), мы можем лишь
воображать себе тот хаос веб-окружений, в который попадут наши страницы, 
делать лучшее, что мы можем и планировать решения на случай худших сценариев.

Со мной часто спорят, мол, применять CSS-классы к HTML-документу с помощью
JavaScript неудобно, когда над проектом работает несколько разработчиков. Так
как в большинстве случаев CSS готов до того, как начинается написание
JavaScript, и классы, которые были созданы для использования
в JavaScript, могут потеряться в общей массе кода. Как результат мы
получаем внушительное количество продублированного кода. В таких случаях я
советую постучать себя по лбу, открыть AIM, GTalk или Skype и сообщить
сотрудникам о классах, которые были созданы специально для использования в
JavaScript. Бытует мнение, что все общение между веб-разработчиками сводится к
обмену сообщениями в системах управления файлами вроде Git, но, поверьте, от
набора пары строчек дополнительного текста никто не пострадает.

## Использование динамического CSS с подстраховкой в Javascript ##

Использование JavaScript для подключения объектов CSS имеет и более широкое
применение, чем сокрытие и отображение содержимого. Оно позволяет использовать
динамические CSS – переходы, анимацию, трансформации – все те эффекты, которые
сейчас зачастую прописываются при помощи JavaScript. Разберем простой пример
применения эффекта постепенного исчезания для div–блока при нажатии на него. В
этом примере продемонстрировано как его можно реализовать с помощью CSS,
продублировав те же эффекты в JavaScript-коде в качестве подстраховки для
браузеров, которые не поддерживают используемое CSS-свойство transition.

Мы будем использовать:
* [jQuery][2] 
* [Modernizr][3]

Сначала подготовим `body`: 

1  <body>
2    <button type="button">Run Transition</button>
3    <div id="cube"></div><!--/#cube-->
4  </body>

Теперь пропишем CSS:

01 #cube {
02   height: 200px;
03   width: 200px;
04   background: orange;
05   -webkit-transition: opacity linear .5s;
06    -moz-transition: opacity linear .5s;
07     -o-transition: opacity linear .5s;
08       transition: opacity linear .5s;
09 }
10  
11 .fade-out {
12   opacity: 0;
13 }

Перед добавлением JavaScript-кода отвлечемся немного чтобы разобраться с тем, что 
мы собираемся сделать:
1. Используем библиотеку Modernizr, чтобы проверить поддерживается ли CSS-свойство 
`transition`.
2. Если оно подерживается:
2.1. Присваиваем кнопке button onclick – событие, которое при нажатии на кнопку будет
подключать класс `fade-out` к элементу с идентификатором `#cube`.
2.2. Добавляем слушатель события, который определит когда будет завершен `transition`. 
Используя его, мы можем задать функцию, которая удалит идентификатор `#cube` из структуры 
DOM.
3. Если transition не поддерживается:
3.1. Присваиваем кнопке button onclick – событие, которое будет запускать метод jQuery 
`animate()`. Это позволит применить эффект постепенного исчезания элемента с идентификатором 
`#cube`.
3.2. Используем callback-функцию, чтобы удалить `#cube` из структуры DOM.

После окончания transition на основе CSS, выполняется дополнительное событие
transitionend. Также в конце более сложных взаимодействий на основе анимации
CSS выполняется дополнительное событие animationend.

Сначала нужно прописать переменные JavaScript:

01 (function () {
02  
03   // прописываем переменные
04   var elem = document.getElementById('cube'),
05     button = document.getElementById('do-it'),
06     transitionTimingFunction = 'linear',
07     transitionDuration = 500,
08     transitionend;
09  
10   // прописываем синтаксис свойства transitionend, используя вендорные префиксы
11   if ($.browser.webkit) {
12     transitionend = 'webkitTransitionEnd'; // safari & chrome
13   } else if ($.browser.mozilla) {
14     transitionend = 'transitionend'; // firefox
15   } else if ($.browser.opera) {
16     transitionend = 'oTransitionEnd'; // opera
17   } else {
18     transitionend = 'transitionend'; // best guess at the default?
19   }
20  
21   //... добавляем остальной код сюда.
22  
23 })(); // конец обёртывающей функции

Вы, наверное, заметили, что для события `transitionend` был добавлен вендорный
префикс и для каждого браузера полностью указано название события. Как правило,
достаточно определить вендорный префикс и добавить его к названию события, но в
этом случае синтаксис немного отличается, поэтому следует указывать имя события
с каждым префиксом целиком.

Далее мы будем использовать Modernizr, чтобы подтвердить поддержку свойства
`transition` и в каждом случае добавим слушатель события (все это помещается в
обёртывающую функцию):

01 // с помощью Modernizr проверяем наличие поддержки transition
02 if(Modernizr.csstransitions) {
03  
04   // подключение класса при клике мышкой
05   $(button).on('click', function () {
06     $(elem).addClass('fade-out');
07   });
08    
09   // имитация callback-функции при помощи слушателя события
10   elem.addEventListener(transitionend, function () {
11     theCallbackFunction(elem);
12   }, false);
13     
14 } else {
15  
16   // слушатель события для браузеров, не поддерживающих предыдущий вариант 
17   $(button).on('click', function () {
18  
19     $(elem).animate({
20       'opacity' : '0'
21     }, transitionDuration, transitionTimingFunction, function () {
22       theCallbackFunction(elem);
23     });
24  
25   }); // конец события
26  
27 } // конец проверки 

И наконец, нам нужно указать общую функцию для обеих процессов, которая будет
выполняться после завершения transition (или animation). Чтобы не усложнять наш
пример, назовем её просто `theCallbackFunction()` (хотя технически – она не
является callback-функцией). Она удалит элемент из структуры DOM и выведет
в консоль сообщение, что функция была выполнена успешно.

01 // прописываем callback-функцию, что происходит после завершения transition/animation
02 function theCallbackFunction (elem) {
03  
04   'use strict';
05  
06   // удаление элемента из DOM
07   $(elem).remove();
08  
09   // вывод сообщения об успешном завершении
10   console.log('the transition is complete');
11  
12 }

Вне зависимости от того, какой браузер используется – от IE 7 (в худшем случае),
до мобильной версии Safari или Chrome – эффект будет идентичным. Разница скрыта
«под капотом», пользователь её не заметит. Подобным образом можно использовать
и другие передовые техники, не жертвуя при этом качеством продукта для
пользователей более старых браузеров. Такой подход также позволяет разделять
CSS и JavaScript, что и было нашей целью.

## Итог ##

Возможно, вы спрашиваете себя: зачем усложнять себе жизнь дополнительной
работой? Мы написали 60 строчек кода JavaScript для того, чтобы воспроизвести
эффект на который требуется 8 строчек jQuery. Что сказать, никто не говорил,
что следить за чистотой кода и придерживаться подхода прогрессивного улучшения
– самая лёгкая задача из выполняемых вами. Напротив, гораздо легче не
обращать на это внимание вовсе. Однако ответственные разработчики
должны следить за тем, чтобы разработанные нами приложения были доступны максимально
широкому кругу пользователей, и в будущем их можно было бы легко перенастроить
под новые требования. Если вам, так же как и мне, не жаль потратить немного
времени на то, чтобы обеспечить бесперебойную работу результата вашего труда,
тогда стоит приложить все усилия для «отделения зерён от плевел» и разработки
приложения, которое будет соответствовать всем требованиям идеологии
постепенного улучшения и «graceful degradation».

Представленная модель также позволяет максимально использовать сильные стороны
CSS, такие как отзывчивый дизайн и возможность корректировки взаимодествия с
пользователем, основываясь на разрешении его экрана. Особенно заметна разница
при использовании устройств с низкой производительностью, ведь
известно, что CSS скачивается и обрабатывается намного быстрее чем JavaScript.
Возможность переложить некоторые задачи с JavaScript на CSS – это огромный плюс.

На практике мы уже используем переходы и анимацию CSS для создания мелких
взаимодействий, таких, как смена внешнего вида элемента при наведении курсора
(hover-эффекты), вращающаяся графика, пульсирующие обьекты. В скором времени
CSS получит статус общепризнанного могущественного языка, который отлично
читается браузерами и будет активно использоваться для построения сложных
взаимодействий, пока не реализованных при помощи JavaScript. Если вам нужен
надежный инструмент, не требующий обильной затраты ресурсов, относительно
простой в вопросах поддержки и позволяющий использовать передовые возможности
браузеров – скорее всего, пришло время пересмотреть свой подход к распределению
задач между CSS и JavaScript. Как сказал один умный человек: «Чтобы написать
хороший код JavaScript, нужно знать, когда вместо него стоит использовать CSS»
(Этот человек - я).

Автор: Тим Райт (Tim Wright)

[1]: http://www.youtube.com/watch?v=jyaLZHiJJnE
[2]: http://jquery.com/
[3]: http://modernizr.com/
